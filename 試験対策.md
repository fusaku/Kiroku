# 試験対策



## 	第一章   簡単なJavaプログラムの作成

1.  パッケージ宣言に関するルール

- パッケージ宣言は必ずソースコードの先頭行に記述する。
- パッケージ宣言よりも前に記述できるのはコメントだけである。

2. javaコマンドでのクラス実行時に指定する起動パラメータは、String配列型オブジェクトに格納されるため、１番目が配列型変数args[0]、２番目がargs[1]……となります。

3. Javaコマンドの起動パラメータに指定する文字列にスペースやダブルクォーテーションが含まれる場合の挙動を確認しておきましょう。

> パッケージ空間の目的
>
> - 名前空間を提供し、名前の衝突を避ける	
> - アクセス修飾子と組み合わせてアクセス制御機能を提供する
> - クラスの分類を可能にする

> エントルーポイントに適用のルール
>
> - 公開されていること（publicであること）
> - インスタンスを生成しなくても実行できること（staticであること）
> - 戻り値は戻せない（voidであること）
> - メソッド名はmainであること
> - 引数はString配列型を1つ受け取ること

> javaコマンドは、JVMを起動するためのコマンドです。
>
> Javaコマンドの構文は次のとおりです。
>

> ```java
> java 完全修飾子クラス名 [引数 引数 ...]
> ```
>

> クラス名のあとに続ける引数のことを「起動パラメータ」や「コマンドライン引数」と呼びます。

> javaコマンドでは、次の3つを実行することができます。
> 
> - mainメソッドを持つクラスファイル
> - jarファイル内のメインクラス
> - モジュールに含まれるメインクラス
> 

```java
> java Sample.java Hello World "Hello World"  //Hello,World,Hello Worldを起動パラメータとして渡す。
Hello
World
Hello World
```
> ダブルクォーテーションを文字として使いたい場合には、「¥"」のように円記号「¥」を前につけてエスケープします。
```java
> java Sample.java Hello World ¥"Hello World¥"
Hello
World
"Hello
World"
```

> - スペースが区切り記号として扱われる。
>
> - スペースを含む文字列はダブルクォーテーションで括ることで1つとして扱われる
> - ダブルクォーテーションそのものは文字として扱われない



## 	第二章   Javaの基本データ型と文字列操作

Javaでは、数値を10進数のほかに、==２進数、８進数、１６進数==のリテラルで表記でき、それぞれ、==0b、0、0x==で始めます。

1. 整数リテラル表記の詳細については、Javaの仕様を確認してください。試験対策としては以下のことを覚えておきましょう。

==リテラルの先頭と末尾には記述できない==

==記号の前後には記述できない==

==利用できる記号は、小数点を表すドット「.」、long型やfloat型リテラルを表す「L」や「F」、２進数を表す「0b」、１６進数を表す「0x」==

| データ型 | 値                                                   |
| -------- | ---------------------------------------------------- |
| boolean  | ture,false                                           |
| char     | 16ビットUnicode文字¥u0000~¥uFFFF                     |
| byte     | 8ビット整数-128~127                                  |
| short    | 16ビット整数-32768~32767                             |
| int      | 32ビット整数-2147483648~2147483647                   |
| long     | 64ビット整数-9223372036853775808~9223372036853775807 |
| float    | 32ビット単精度浮動小数点                             |
| double   | 64ビット倍精度浮動小数点                             |


3. char型の変数には、ダブルクォーテーション==「”」==で括った文字列リテラルは代入できません。==代入できる==のは、シングルクォーテーション「'」で括った==文字リテラル==、もしくは==数値==のみです。シングルクォーテーション、ダブルクォーテーションを間違えないようにしましょう。

> シングルクォーテーションで括った文字（文字リテラル）
>
> シングルクォーテーションでくくった 「¥u」から始まるUnicode番号（文字リテラル）
>
> 0~66535までの数値（数値リテラル）

4. 識別子に使える記号はアンダースコア「_」とドル記号「$」であることと、数字は2文字名以降に使えることを理解しましょう。特に、変数名は数字から始めてはいけないことはよく覚えておきましょう。

> - **予約語を識別子（しきべつし）として使うことはできない**
>
> - 使える記号は、**==アンダースコア==**「==_==」と**==通貨記号==**のみ
>
> - **数字から始めてはいけない**（２文字以降であれば使用可）
>
>   【Javaの予約語】
>
>   | abstarct          | assert       | boolean   | break     | byte   |
>   | ----------------- | ------------ | --------- | --------- | ------ |
>   | case              | catch        | char      | class     | const  |
>   | contiue           | default      | do        | double    | else   |
>   | enum              | extends      | final     | finally   | float  |
>   | instanceof        | int          | interface | long      | native |
>   | new               | package      | private   | protected | public |
>   | return            | short        | static    | strictfp  | super  |
>   | switch            | synchronized | this      | throw     | throws |
>   | transient         | try          | void      | volatile  | while  |
>   | _(アンダースコア) |              |           |           |        |
>
>   







4. var型を使った型推論では、コンパイル時に代入演算子の右辺から変数のデータ型が推論(すいろん)され、そのデータ型に置き換えられます。変数宣言以降の行で、その変数がどのように使われているかは遠慮されません。

> varによる型推論は、==ローカル変数の宣言==（局部变量的声明）にしか使えません。
>
> > varを使った変数宣言
> >
> > ```java
> > var a = 10;
> > ```
> >
> > メソッドの戻り値からローカル変数の型を推論する
> >
> > ```java
> > var a = sample();
> > ```



> Stringクラスのインスタンスを生成する方法（代表的）
>
> - **new**を使ってインスタンス化する
> - **ダブルクォーテーション「"」****で括って文字列リテラル**を記述する



4. Stringクラスについて、以下の２点を確認しておきましょう。

```
Stringはimmutableなオブジェクトあるため、文字列を変更するには新しくインスタンスを作らなければいけない

replaceAllメソッドをはじめとするStringクラスのメソッドを挙動(きょどう)
```


> 変更できないオブジェクトのことを「mutable(可変)なオブジェクト」、変更できないオブジェクトのことを「immubtable(不可変)なオブジェクト」と呼びます。

>immutableなオブジェクトを定義するには
>
>- すべでの**フィールド（字段）をprivate**で修飾する
>- オブジェクト内部の状態を変更可能なメソッドを提供しない(例えば**setterメソッド**を提供しない)
>- **クラスをfinal**で宣言し、メソッドがオーバーライドされないことを保証する(サブクラスからの変更を防ぐ)
>- 内部に可変オブジェクトを保持している場合、そのオブジェクト外部に提供しない(例えば**getterメソッド**を提供しない)
>
>例 immutableなクラス
>
>```java
>public final class Sample {
>  private final String name;
>  public Sample(String name) {
>    this.name = name;
>  }
>  public void greet(){
>    System.out.println("hello," + name);
>  }
>}
>```



> **==charAtメソッド==**はインスタンスが保持している文字列から、引数で指定された位置にある１文字だけを**抜き出して戻し**ます。

7. **chatAtメソット**の引数に指定する文字番号は、０から始まります。lengthメソッドは、半角文字・全角文字のいずれも１文字として扱い、<u>「文字数」を戻します</u>。

> **==indexOfメソッド==**は、引数で指定された文字が文字列のどの位置に存在するかを**調べる**ためのメソッドです。

8. **substringメソッド**には、１つしか引数を取らないものもあります。その場合は開始位置だけを指定していることになり、開始位置以降に現れる全ての文字を抽出します。

> **==substeingメソッド==**は、文字列から任意の文字列を**抽出する**メソッドです。文字列を指定するために使う範囲は次の図のように
>
> 文字列イメージ
> | a | b | c | d | e |
> 0    1    2    3    4    5



> **==replaceメソッド==**は、文字列を**置き換える**ためのメソッドです。文字列の置き換えは先頭から始まり、文字列の最後まで行われます。

9. **replaceメソッド**は、第1引数に指定した文字列があれば、順番に全て置換します。

```java
replaceメソッドの引数は、char型かCharSequence型のうち、どちらか片方しか受け取りません。
```

10. charAtメソッドに渡される文字位置は０から始まります。

```
lengthメソッドは、半角文字・全角文字のいずれも１文字として扱い、「文字数」を戻します。
```

11. Stringクラスの多くのメソッドは、新しいStringインスタンスを作って戻します。Stringはimmutableなクラスであるため、元の文字列が変更されることはありません。
11. 文字列の連結について、以下のことを覚えておきましょう

- +演算子は、文字列を連結する
- 数値と文字列の場合は、数値が文字列に置き換わってから文字列として連結される
- 数値加算と文字列連結が混在する式は、左から順に実行される。

13. StringBuliderは、デフォルトで１６文字分のバッファを持っています。

14. 文字列を引数に渡すコンストラクタを使った場合、StringBuilderのインスタンスは、「文字列の長さ＋１６文字分」のバッファを持っています。

15. java.lang.StringBuilderクラスの==appendメソッド==は、文字列に新しい文字列を追加するメソッドです

16. > 文字列イメージ
    > | a | b | c | d | e |
    > 0    1    2    3    4    5

16. java.lang.StringBuilderクラスの==indexOfメソッド==は、StringBuilderのインスタンスが保持している文字列のうち、引数で受け取った文字列の「開始位置」を戻します。

    > 文字列イメージ
    >
    > | a    | b    | c    | d    | e    |
    > | ---- | ---- | ---- | ---- | ---- |
    > | 0    | 1    | 2    | 3    | 4    |



## 	第三章   演算子と判定構造

[代入演算子]

| 演算子 | 使用例   | 意味                                                         |
| ------ | -------- | ------------------------------------------------------------ |
| =      | a = 10;  | 変数aに10を代入する                                          |
| +=     | a += 10; | 「a = a + 10」と同じ。変数aの値に10を足してから、変数aに結果を代入する |
| -=     | a -= 10; | 「a = a - 10」と同じ。変数aの値に10を引いてから、変数aに結果を代入する |
| *=     | a *= 10; | 「a = a * 10」と同じ。変数aの値に10を掛けてから、変数aに結果を代入する |
| /=     | a /= 10; | 「a = a / 10」と同じ。変数aの値に10を割ってから、変数aに結果を代入する |

1. byteとshortは扱う範囲が狭いデータ型です。この２つのデータ型については、正確(せいかく)に範囲を覚えておきましょう。

2. Javaではbyte型のような数値型とboolean型に互換性はありません。このため、byte型に真偽値(true/false)を代入したり、boolean型に０や１という数値を代入することはできません。このような互換性がある、その他のプログラミング言語を学んだ方は注意しましょう。

3. インクリメント演算子とデクリメント演算子の前置と後置の違いによる演算の動作順序は重要なポイントです。一時変数がどのタイミングで加算や減算さらるかをしっかりと覚えておきましょう。

4. 「＞」「＞＝」「＜」「＜＝」の4つの関係演算子に関する問題は、オプランドの値を含むかどうかを確認しましょう。

```
			「＞」と「＜」はオプランドの値を含まず、「＞＝」と「＜＝」はオプランドの値を含みます。
```

5. Javaには数多くの演算子があり、それぞれ優先順位が異なります。試験対策としてすべてを覚える必要はありませんが、以下のことえを覚えておきましょう。

```
			カッコやインクリメント、デクリメントが最優先である

			数学と同じで乗算と除算、剰余算が、加算や減算よりも優先される。
```

6. 異なるインスタンス同士が同じ値を持っているか（同値であるか）を確認するには、equalsメソッドを使います。	

7. Objectクラスのequalsメソッドは、Object型を引数に受け取り、boolean型の戻り値を戻します。

## 	第四章   制御構造

1. while文やdo-while文では、中カッコを省略した場合、次の１文だけ繰り戻しの対象となります。

2.  do-while文で中カッコを省略した場合は、doとwhileの間には１文のみを記述できます。２文以上記述(きじゅつ)した場合には、コンパイルエラーが発生します。

3. for文で複数の条件文を記述する場合は、論理演算子を使います。初期化文や更新文のように、カンマ「,」で区切って複数の条件を記述するとコンパイルエラーになります。

4.  更新文は、繰り戻し処理が終わってから実行されます。初期化文→条件文→繰り戻し処理→更新文（→条件文へ）という、実行の順番を正確に覚えておきましょう。

5. 二重ループの問題が出題されたときは、選択肢ごとに表を作って確認していくと良いでしょう。

6. for文の条件式と更新式は省略できます。

7. for文の条件式を省略した場合は、break（解答１４を参照）を使わない限り、無限ループとなります。

8. 拡張for文の構文は「一時変数の宣言 : コレクション/配列」です。

- 順番を間違いないように気をつけてください。


9. 拡張for文の集合には、配列とjava.util.ArrayListが使えることを覚えておきましょう。
